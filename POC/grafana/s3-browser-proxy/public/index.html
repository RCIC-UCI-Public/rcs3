<!--
    S3 Browser - Frontend Web Interface
    
    A single-page web application for browsing AWS S3 buckets with read-only access.
    Features include folder navigation, file selection, version history, and deleted file detection.
    
    Technology Stack:
    - Pure HTML5 with semantic markup
    - CSS3 with Flexbox and modern styling (no frameworks)
    - Vanilla JavaScript (ES5/ES6) - no libraries or frameworks
    - Responsive design for desktop and mobile
    - RESTful API communication with fetch()
    
    Architecture: Single-page application (SPA) with client-side routing and state management
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S3 Browser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .controls-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            background: white;
        }

        .version-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
        }

        .version-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .item.version-item {
            border-left: 3px solid #007bff;
            margin-left: 10px;
            background-color: #f8f9fa;
        }

        .item.delete-marker {
            border-left: 3px solid #dc3545;
            background-color: #fff5f5;
        }

        .item.delete-marker .file-icon {
            color: #dc3545;
        }

        .version-badge {
            display: inline-block;
            background: #007bff;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: bold;
        }

        .version-badge.latest {
            background: #28a745;
        }

        .version-badge.delete-marker {
            background: #dc3545;
        }

        .version-indicator {
            display: inline-block;
            background: #17a2b8;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: bold;
            cursor: help;
        }

        .version-indicator:hover {
            background: #138496;
        }

        .selection-checkbox:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .item-name.non-selectable {
            color: #6c757d;
            cursor: default;
        }

        .item-name.non-selectable:hover {
            text-decoration: none;
        }

        .breadcrumb {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .breadcrumb a {
            color: #007bff;
            text-decoration: none;
            margin-right: 5px;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .content {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .folder-list, .file-list {
            margin: 20px;
        }

        .folder-list h3, .file-list h3 {
            margin-bottom: 15px;
            color: #495057;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #f8f9fa;
            transition: background-color 0.2s ease;
        }

        .item:hover {
            background-color: #f8f9fa;
        }

        .item:last-child {
            border-bottom: none;
        }

        .icon {
            margin-right: 12px;
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .folder-icon {
            color: #ffd700;
        }

        .file-icon {
            color: #6c757d;
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            font-weight: 500;
            font-size: 16px;
            margin-bottom: 4px;
            cursor: pointer;
            color: #007bff;
        }

        .item-name:hover {
            text-decoration: underline;
        }

        .item-details {
            font-size: 12px;
            color: #6c757d;
            display: flex;
            gap: 15px;
        }

        .item-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 3px;
        }

        .selection-checkbox {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .selection-controls {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .selection-controls h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .selection-summary {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
            font-size: 14px;
            max-height: 200px;
            overflow-y: auto;
        }

        .selection-item {
            padding: 2px 0;
            color: #6c757d;
        }

        .selection-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 20px;
            border: 1px solid #f5c6cb;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #6c757d;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 10px 20px;
            border-top: 1px solid #dee2e6;
            font-size: 14px;
            color: #6c757d;
        }

        /* Modal Dialog Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 0;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px 10px 0 0;
        }

        .modal-header h3 {
            margin: 0;
            font-size: 20px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 28px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background-color 0.2s ease;
        }

        .modal-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            max-height: calc(80vh - 80px);
        }

        .version-item {
            padding: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 10px;
            background: white;
            transition: box-shadow 0.2s ease;
        }

        .version-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .version-item.current {
            border-color: #28a745;
            background: #f8fff9;
        }

        .version-item.deleted {
            border-color: #dc3545;
            background: #fff5f5;
        }

        .version-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .version-title {
            font-weight: 600;
            font-size: 16px;
        }

        .version-title.current {
            color: #28a745;
        }

        .version-title.deleted {
            color: #dc3545;
        }

        .version-badge-modal {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .version-badge-modal.current {
            background: #28a745;
            color: white;
        }

        .version-badge-modal.deleted {
            background: #dc3545;
            color: white;
        }

        .version-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
            font-size: 14px;
            color: #6c757d;
        }

        .version-detail {
            display: flex;
            justify-content: space-between;
        }

        .version-detail strong {
            color: #495057;
        }

        .version-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        /* Load More Button Styles */
        .load-more-container {
            text-align: center;
            padding: 20px;
            border-top: 1px solid #f8f9fa;
        }

        .load-more-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .load-more-btn:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .load-more-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .load-more-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid transparent;
            border-top: 2px solid currentColor;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .item {
                flex-direction: column;
                align-items: flex-start;
            }

            .item-actions {
                margin-top: 10px;
                align-self: flex-end;
            }

            .modal-content {
                margin: 2% auto;
                width: 95%;
                max-height: 90vh;
            }

            .version-details {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🗄️ S3 Browser</h1>
            <p>Browse AWS S3 buckets and objects with read-only access</p>
        </div>

        <div class="controls">
            <div class="controls-row">
                <select id="bucketSelect">
                    <option value="">Select a bucket...</option>
                </select>
                <button class="btn" onclick="refreshBuckets()">🔄 Refresh Buckets</button>
                <button class="btn btn-secondary" onclick="reloadCredentials()">🔑 Reload Credentials</button>
            </div>
            <div class="controls-row">
                <label class="version-toggle">
                    <input type="checkbox" id="checkVersions" onchange="toggleVersionChecking()">
                    📊 Show Version Badges
                </label>
                <label class="version-toggle">
                    <input type="checkbox" id="showDeleted" onchange="toggleDeletedChecking()">
                    🗑️ Show Deleted Files
                </label>
            </div>
        </div>

        <div id="breadcrumb" class="breadcrumb" style="display: none;">
            <span id="breadcrumbContent"></span>
        </div>

        <div id="selectionControls" class="selection-controls">
            <h3>📋 Selected Items</h3>
            <div class="selection-buttons">
                <button class="btn btn-small" onclick="selectAll()">Select All</button>
                <button class="btn btn-small btn-secondary" onclick="clearSelection()">Clear Selection</button>
                <button class="btn btn-small" onclick="showSelectionDetails()">Show Details</button>
                <button class="btn btn-small" onclick="copySelectionToClipboard()">📋 Copy List</button>
            </div>
            <div id="selectionSummary" class="selection-summary" style="display: none;">
                <div id="selectionList"></div>
            </div>
        </div>

        <div class="content">
            <div id="loading" class="loading" style="display: none;">
                <div class="spinner"></div>
                <p>Loading...</p>
            </div>

            <div id="error" class="error" style="display: none;"></div>

            <div id="emptyState" class="empty-state">
                <h3>👆 Select a bucket to get started</h3>
                <p>Choose a bucket from the dropdown above to browse its contents</p>
            </div>

            <div id="folderList" class="folder-list" style="display: none;">
                <h3>📁 Folders</h3>
                <div id="folders"></div>
            </div>

            <div id="fileList" class="file-list" style="display: none;">
                <h3>📄 Files</h3>
                <div id="files"></div>
            </div>

            <div id="statusBar" class="status-bar" style="display: none;">
                <span id="statusText"></span>
            </div>
        </div>
    </div>

    <!-- Version Details Modal -->
    <div id="versionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="versionModalTitle">📄 File Versions</h3>
                <button class="modal-close" onclick="closeVersionModal()">&times;</button>
            </div>
            <div class="modal-body" id="versionModalBody">
                <!-- Version details will be populated here -->
            </div>
        </div>
    </div>

    <script>
        let currentBucket = '';
        let currentPrefix = '';
        let selectedItems = new Set(); // Stores selected paths
        let currentFolders = []; // Cache current folder list
        let currentFiles = []; // Cache current file list
        let currentContinuationToken = null; // For pagination
        let isLoadingMore = false; // Prevent multiple concurrent loads

        // Detect base path from current location and set it once
        const BASE_PATH = (function() {
            const path = window.location.pathname;
            // If we're at /s3browser/, return /s3browser
            // If we're at root /, return empty string
            if (path.includes('/s3browser')) {
                return '/s3browser';
            }
            return '';
        })();

        // Helper function to build API URLs with correct base path
        function apiUrl(endpoint) {
            return BASE_PATH + endpoint;
        }

        // Get filtered buckets from URL parameters
        function getFilteredBuckets() {
            const urlParams = new URLSearchParams(window.location.search);
            const filter = urlParams.get('filter');
            return filter ? filter.split(',').map(b => b.trim()) : null;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            checkRuntimeEnvironment(); // Check if server-hosted and hide client features
            loadBuckets();
            setupEventDelegation(); // Set up event delegation
            
            document.getElementById('bucketSelect').addEventListener('change', function() {
                const selectedBucket = this.value;
                if (selectedBucket) {
                    currentBucket = selectedBucket;
                    currentPrefix = '';
                    selectedItems.clear(); // Clear selections when switching buckets
                    loadObjects();
                } else {
                    showEmptyState();
                    document.getElementById('selectionControls').style.display = 'none';
                }
            });
        });

        // Set up event delegation for dynamic content
        function setupEventDelegation() {
            // Event delegation for folders container
            document.getElementById('folders').addEventListener('click', handleFolderClick);
            document.getElementById('folders').addEventListener('change', handleCheckboxChange);
            
            // Event delegation for files container
            document.getElementById('files').addEventListener('click', handleFileClick);
            document.getElementById('files').addEventListener('change', handleCheckboxChange);
        }

        // Handle clicks in folders container
        function handleFolderClick(event) {
            const target = event.target;
            
            // Handle folder navigation
            if (target.dataset.action === 'navigate-folder') {
                event.preventDefault();
                const prefix = target.dataset.prefix;
                navigateToFolder(prefix);
            }
        }

        // Handle clicks in files container
        function handleFileClick(event) {
            const target = event.target;
            
            // Handle file details
            if (target.dataset.action === 'show-file-details') {
                event.preventDefault();
                const key = target.dataset.key;
                showFileDetails(key);
            }
            
            // Handle metadata button
            if (target.dataset.action === 'show-metadata') {
                event.preventDefault();
                const key = target.dataset.key;
                showMetadata(key);
            }
        }

        // Handle checkbox changes using event delegation
        function handleCheckboxChange(event) {
            const target = event.target;
            
            if (target.classList.contains('selection-checkbox')) {
                const path = target.dataset.path;
                const type = target.dataset.type;
                const isChecked = target.checked;
                toggleSelection(path, type, isChecked);
            }
        }

        // Check runtime environment and hide client-side features when server-hosted
        async function checkRuntimeEnvironment() {
            try {
                const response = await fetch(apiUrl('/api/runtime-info'));
                if (response.ok) {
                    const runtimeInfo = await response.json();
                    
                    console.log('Runtime environment:', runtimeInfo);
                    
                    if (runtimeInfo.isServerHosted) {
                        // Hide reload credentials button when server-hosted (using IAM role)
                        const reloadCredentialsBtn = document.querySelector('button[onclick="reloadCredentials()"]');
                        if (reloadCredentialsBtn) {
                            reloadCredentialsBtn.style.display = 'none';
                        }
                        
                        // Hide refresh buckets button when server-hosted (not needed on server)
                        const refreshBucketsBtn = document.querySelector('button[onclick="refreshBuckets()"]');
                        if (refreshBucketsBtn) {
                            refreshBucketsBtn.style.display = 'none';
                        }
                        
                        console.log('Server-hosted environment detected - hiding client-only buttons');
                    } else {
                        console.log('Local development environment detected - showing all buttons');
                    }
                }
            } catch (error) {
                console.warn('Could not determine runtime environment:', error);
                // Assume local environment if API call fails
            }
        }

        // Load available buckets
        async function loadBuckets() {
            try {
                showLoading();
                const response = await fetch(apiUrl('/api/buckets'));
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const buckets = await response.json();
                const select = document.getElementById('bucketSelect');
                
                // Clear existing options except the first one
                select.innerHTML = '<option value="">Select a bucket...</option>';
                
                // Get filtered bucket list if filter parameter exists
                const filteredBucketNames = getFilteredBuckets();
                const bucketsToShow = filteredBucketNames ? 
                    buckets.filter(bucket => filteredBucketNames.includes(bucket.Name)) : 
                    buckets;
                
                bucketsToShow.forEach(bucket => {
                    const option = document.createElement('option');
                    option.value = bucket.Name;
                    option.textContent = `${bucket.Name} (Created: ${new Date(bucket.CreationDate).toLocaleDateString()})`;
                    select.appendChild(option);
                });
                
                hideLoading();
                if (bucketsToShow.length === 0) {
                    if (filteredBucketNames) {
                        showError(`No accessible buckets found from filter: ${filteredBucketNames.join(', ')}`);
                    } else {
                        showError('No buckets found. Please check your AWS credentials and permissions.');
                    }
                } else {
                    showEmptyState();
                    
                    // If only one bucket is available, auto-select it
                    if (bucketsToShow.length === 1) {
                        select.value = bucketsToShow[0].Name;
                        currentBucket = bucketsToShow[0].Name;
                        currentPrefix = '';
                        selectedItems.clear();
                        loadObjects();
                    }
                }
            } catch (error) {
                console.error('Error loading buckets:', error);
                showError(`Failed to load buckets: ${error.message}`);
                hideLoading();
            }
        }

        // Toggle version checking on/off
        function toggleVersionChecking() {
            // Reload current view with new version checking setting
            if (currentBucket) {
                loadObjects();
            }
        }

        // Toggle deleted files checking on/off
        function toggleDeletedChecking() {
            // If showing deleted files is enabled, automatically enable version badges
            const showDeleted = document.getElementById('showDeleted').checked;
            const checkVersions = document.getElementById('checkVersions');
            
            if (showDeleted && !checkVersions.checked) {
                checkVersions.checked = true;
                console.log('Auto-enabled version badges because deleted files requires version info');
            }
            
            // Reload current view with new settings
            if (currentBucket) {
                loadObjects();
            }
        }

        // Load objects in current bucket/prefix
        async function loadObjects(isLoadMore = false) {
            if (!currentBucket) return;
            
            try {
                if (!isLoadMore) {
                    showLoading();
                    // Reset pagination state for new folder
                    currentContinuationToken = null;
                }
                
                const showVersionInfo = document.getElementById('checkVersions').checked;
                const showDeleted = document.getElementById('showDeleted').checked;
                
                // Build URL with pagination parameters
                let url = `/api/buckets/${encodeURIComponent(currentBucket)}/objects?prefix=${encodeURIComponent(currentPrefix)}&showVersionInfo=${showVersionInfo}&showDeleted=${showDeleted}`;
                
                // Add continuation token for pagination
                if (isLoadMore && currentContinuationToken) {
                    url += `&continuationToken=${encodeURIComponent(currentContinuationToken)}`;
                }
                
                
                const response = await fetch(apiUrl(url));
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Update pagination token
                currentContinuationToken = data.nextContinuationToken || null;
                
                if (isLoadMore) {
                    // Append new data to existing lists
                    appendObjects(data);
                } else {
                    // Replace data for new folder
                    displayObjects(data);
                    updateBreadcrumb();
                }
                
                hideLoading();
            } catch (error) {
                console.error('Error loading objects:', error);
                showError(`Failed to load objects: ${error.message}`);
                hideLoading();
            }
        }

        // Display folders and files
        function displayObjects(data) {
            hideError();
            
            // Cache the current data
            currentFolders = data.folders || [];
            currentFiles = data.files || [];
            
            const foldersContainer = document.getElementById('folders');
            const filesContainer = document.getElementById('files');
            const folderList = document.getElementById('folderList');
            const fileList = document.getElementById('fileList');
            
            // Clear previous content
            foldersContainer.innerHTML = '';
            filesContainer.innerHTML = '';
            
            // Show/hide sections based on content
            const hasFolders = currentFolders.length > 0;
            const hasFiles = currentFiles.length > 0;
            
            folderList.style.display = hasFolders ? 'block' : 'none';
            fileList.style.display = hasFiles ? 'block' : 'none';
            
            if (!hasFolders && !hasFiles) {
                showEmptyFolder();
                return;
            }
            
            hideEmptyState();
            
            // Display folders
            if (hasFolders) {
                currentFolders.forEach(folder => {
                    const folderElement = createFolderElement(folder);
                    foldersContainer.appendChild(folderElement);
                });
            }
            
            // Display files
            if (hasFiles) {
                currentFiles.forEach(file => {
                    const fileElement = createFileElement(file);
                    filesContainer.appendChild(fileElement);
                });
            }
            
            // Add "Load More" button if there are more items
            addLoadMoreButton(data.isTruncated);
            
            // Update status bar
            updateStatusBar(currentFolders.length, currentFiles.length);
            
            // Show selection controls if we have content
            document.getElementById('selectionControls').style.display = (hasFolders || hasFiles) ? 'block' : 'none';
            
            // Update selection states
            updateSelectionUI();
        }

        // Append new objects for pagination
        function appendObjects(data) {
            hideError();
            
            // Append new data to existing arrays
            const newFolders = data.folders || [];
            const newFiles = data.files || [];
            
            currentFolders = currentFolders.concat(newFolders);
            currentFiles = currentFiles.concat(newFiles);
            
            const foldersContainer = document.getElementById('folders');
            const filesContainer = document.getElementById('files');
            const folderList = document.getElementById('folderList');
            const fileList = document.getElementById('fileList');
            
            // Show sections if they have content now
            const hasFolders = currentFolders.length > 0;
            const hasFiles = currentFiles.length > 0;
            
            folderList.style.display = hasFolders ? 'block' : 'none';
            fileList.style.display = hasFiles ? 'block' : 'none';
            
            // Append new folders
            newFolders.forEach(folder => {
                const folderElement = createFolderElement(folder);
                foldersContainer.appendChild(folderElement);
            });
            
            // Append new files
            newFiles.forEach(file => {
                const fileElement = createFileElement(file);
                filesContainer.appendChild(fileElement);
            });
            
            // Update the "Load More" button
            updateLoadMoreButton(data.isTruncated);
            
            // Update status bar with total counts
            updateStatusBar(currentFolders.length, currentFiles.length);
            
            // Update selection states for new items
            updateSelectionUI();
        }

        // Add or update "Load More" button
        function addLoadMoreButton(isTruncated) {
            // Remove existing load more container
            const existingContainer = document.querySelector('.load-more-container');
            if (existingContainer) {
                existingContainer.remove();
            }
            
            if (isTruncated) {
                const contentDiv = document.querySelector('.content');
                const loadMoreContainer = document.createElement('div');
                loadMoreContainer.className = 'load-more-container';
                loadMoreContainer.innerHTML = `
                    <button class="load-more-btn" onclick="loadMoreItems()" id="loadMoreBtn">
                        📄 Load More Items
                    </button>
                `;
                contentDiv.appendChild(loadMoreContainer);
            }
        }

        // Update existing "Load More" button
        function updateLoadMoreButton(isTruncated) {
            const existingContainer = document.querySelector('.load-more-container');
            if (existingContainer && !isTruncated) {
                existingContainer.remove();
            } else if (!existingContainer && isTruncated) {
                addLoadMoreButton(true);
            }
            
            // Reset button state
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            if (loadMoreBtn) {
                loadMoreBtn.disabled = false;
                loadMoreBtn.innerHTML = '📄 Load More Items';
                isLoadingMore = false;
            }
        }

        // Load more items function
        async function loadMoreItems() {
            if (isLoadingMore || !currentContinuationToken) {
                return;
            }
            
            isLoadingMore = true;
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            
            if (loadMoreBtn) {
                loadMoreBtn.disabled = true;
                loadMoreBtn.innerHTML = `
                    <span class="load-more-spinner"></span>
                    Loading...
                `;
            }
            
            try {
                await loadObjects(true); // true indicates this is a "load more" operation
            } catch (error) {
                console.error('Error loading more items:', error);
                showError(`Failed to load more items: ${error.message}`);
                
                // Reset button state on error
                if (loadMoreBtn) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.innerHTML = '📄 Load More Items';
                }
                isLoadingMore = false;
            }
        }

        // Create folder element using DOM API
        function createFolderElement(folder) {
            const div = document.createElement('div');
            div.className = 'item';
            
            const folderName = folder.Prefix.slice(currentPrefix.length).replace(/\/$/, '');
            const folderPath = folder.Prefix;
            const isSelected = isItemSelected(folderPath);
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'selection-checkbox';
            checkbox.dataset.path = folderPath;
            checkbox.dataset.type = 'folder';
            checkbox.checked = isSelected;
            
            // Create folder icon
            const iconSpan = document.createElement('span');
            iconSpan.className = 'icon folder-icon';
            iconSpan.textContent = '📁';
            
            // Create item info container
            const itemInfo = document.createElement('div');
            itemInfo.className = 'item-info';
            
            // Create folder name element
            const itemName = document.createElement('div');
            itemName.className = 'item-name';
            itemName.textContent = folderName;
            itemName.dataset.action = 'navigate-folder';
            itemName.dataset.prefix = folder.Prefix;
            
            itemInfo.appendChild(itemName);
            
            // Assemble the element
            div.appendChild(checkbox);
            div.appendChild(iconSpan);
            div.appendChild(itemInfo);
            
            return div;
        }

        // Create file element using DOM API
        function createFileElement(file) {
            const div = document.createElement('div');
            div.className = 'item';
            
            // Special handling for deleted files
            if (file.IsDeleted) {
                div.classList.add('delete-marker');
            }
            
            const fileName = file.Key.slice(currentPrefix.length);
            const fileSize = file.IsDeleted ? 'Deleted' : formatFileSize(file.Size || 0);
            const lastModified = new Date(file.LastModified).toLocaleString();
            const isSelected = isItemSelected(file.Key);
            
            // Create checkbox
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'selection-checkbox';
            checkbox.dataset.path = file.Key;
            checkbox.dataset.type = 'file';
            checkbox.checked = isSelected;
            
            // Create file icon
            const iconSpan = document.createElement('span');
            iconSpan.className = 'icon file-icon';
            iconSpan.textContent = file.IsDeleted ? '🗑️' : '📄';
            
            // Create item info container
            const itemInfo = document.createElement('div');
            itemInfo.className = 'item-info';
            
            // Create file name element
            const itemName = document.createElement('div');
            itemName.className = 'item-name';
            itemName.textContent = fileName;
            itemName.dataset.action = 'show-file-details';
            itemName.dataset.key = file.Key;
            
            // Add version indicator if file has multiple versions
            if (file.HasMultipleVersions) {
                const versionIndicator = document.createElement('span');
                versionIndicator.className = 'version-indicator';
                versionIndicator.title = `This file has ${file.VersionCount} versions`;
                versionIndicator.textContent = `📊 ${file.VersionCount}`;
                itemName.appendChild(versionIndicator);
            }
            
            // Add deleted indicator for deleted files
            if (file.IsDeleted) {
                const deletedIndicator = document.createElement('span');
                deletedIndicator.className = 'version-badge delete-marker';
                deletedIndicator.title = 'This file has been deleted';
                deletedIndicator.textContent = '🗑️ DELETED';
                itemName.appendChild(deletedIndicator);
            }
            
            // Create file details
            const itemDetails = document.createElement('div');
            itemDetails.className = 'item-details';
            
            const sizeSpan = document.createElement('span');
            sizeSpan.textContent = `Size: ${fileSize}`;
            itemDetails.appendChild(sizeSpan);
            
            const timeLabel = file.IsDeleted ? 'Deleted' : 'Modified';
            const timeSpan = document.createElement('span');
            timeSpan.textContent = `${timeLabel}: ${lastModified}`;
            itemDetails.appendChild(timeSpan);
            
            const storageClass = file.IsDeleted ? 'DELETE_MARKER' : (file.StorageClass || 'STANDARD');
            const storageSpan = document.createElement('span');
            storageSpan.textContent = `Storage: ${storageClass}`;
            itemDetails.appendChild(storageSpan);
            
            itemInfo.appendChild(itemName);
            itemInfo.appendChild(itemDetails);
            
            // Create actions container
            const itemActions = document.createElement('div');
            itemActions.className = 'item-actions';
            
            const infoButton = document.createElement('button');
            infoButton.className = 'btn btn-small';
            infoButton.textContent = 'ℹ️ Info';
            infoButton.dataset.action = 'show-metadata';
            infoButton.dataset.key = file.Key;
            
            itemActions.appendChild(infoButton);
            
            // Assemble the element
            div.appendChild(checkbox);
            div.appendChild(iconSpan);
            div.appendChild(itemInfo);
            div.appendChild(itemActions);
            
            return div;
        }

        // Navigate to folder
        function navigateToFolder(prefix) {
            currentPrefix = prefix;
            loadObjects();
        }

        // Navigate up (breadcrumb navigation)
        function navigateUp(targetPrefix) {
            currentPrefix = targetPrefix;
            loadObjects();
        }

        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            const breadcrumbContent = document.getElementById('breadcrumbContent');
            
            if (!currentPrefix) {
                breadcrumb.style.display = 'none';
                return;
            }
            
            breadcrumb.style.display = 'block';
            
            let html = `<a href="#" onclick="navigateUp('')">🏠 ${currentBucket}</a> / `;
            
            const parts = currentPrefix.split('/').filter(part => part);
            let path = '';
            
            parts.forEach((part, index) => {
                path += part + '/';
                if (index === parts.length - 1) {
                    html += `<span>${part}</span>`;
                } else {
                    html += `<a href="#" onclick="navigateUp('${path}')">${part}</a> / `;
                }
            });
            
            breadcrumbContent.innerHTML = html;
        }

        // Show file metadata
        async function showMetadata(key, versionId = null) {
            try {
                let url = `/api/buckets/${encodeURIComponent(currentBucket)}/objects/${encodeURIComponent(key)}/metadata`;
                if (versionId) {
                    url += `?versionId=${encodeURIComponent(versionId)}`;
                }
                
                const response = await fetch(apiUrl(url));
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const metadata = await response.json();
                
                let info = `File: ${key}\n`;
                if (versionId) {
                    info += `Version ID: ${versionId}\n`;
                }
                info += `\n`;
                info += `Size: ${formatFileSize(metadata.ContentLength)}\n`;
                info += `Last Modified: ${new Date(metadata.LastModified).toLocaleString()}\n`;
                info += `Content Type: ${metadata.ContentType || 'Unknown'}\n`;
                info += `ETag: ${metadata.ETag}\n`;
                
                if (metadata.VersionId) {
                    info += `Version ID: ${metadata.VersionId}\n`;
                }
                
                if (metadata.StorageClass) {
                    info += `Storage Class: ${metadata.StorageClass}\n`;
                }
                
                if (metadata.Metadata && Object.keys(metadata.Metadata).length > 0) {
                    info += `\nCustom Metadata:\n`;
                    Object.entries(metadata.Metadata).forEach(([key, value]) => {
                        info += `  ${key}: ${value}\n`;
                    });
                }
                
                alert(info);
            } catch (error) {
                console.error('Error fetching metadata:', error);
                alert(`Failed to load metadata: ${error.message}`);
            }
        }

        // Show detailed file information including versions in modal
        async function showFileDetails(key) {
            try {
                // Get file versions
                const versionsUrl = `/api/buckets/${encodeURIComponent(currentBucket)}/objects/${encodeURIComponent(key)}/versions`;
                const versionsResponse = await fetch(apiUrl(versionsUrl));
                
                if (!versionsResponse.ok) {
                    throw new Error(`HTTP ${versionsResponse.status}: ${versionsResponse.statusText}`);
                }
                
                const versions = await versionsResponse.json();
                
                // Update modal title
                const modalTitle = document.getElementById('versionModalTitle');
                modalTitle.textContent = `📄 ${key.split('/').pop()}`;
                
                // Build modal content
                const modalBody = document.getElementById('versionModalBody');
                
                if (versions.length === 0) {
                    modalBody.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #6c757d;">
                            <h3>⚠️ No versions found</h3>
                            <p>Versioning may not be enabled on this bucket</p>
                            <br>
                            <div style="text-align: left; max-width: 400px; margin: 0 auto;">
                                <h4>💡 To view version history:</h4>
                                <ul>
                                    <li>Enable versioning on the S3 bucket</li>
                                    <li>Upload new versions of the file</li>
                                </ul>
                                <p><strong>Note:</strong> This is a read-only browser - use the "ℹ️ Info" button for metadata.</p>
                            </div>
                        </div>
                    `;
                } else if (versions.length === 1) {
                    const version = versions[0];
                    modalBody.innerHTML = `
                        <div class="version-item current">
                            <div class="version-header">
                                <span class="version-title current">Single Version</span>
                                <span class="version-badge-modal current">Current</span>
                            </div>
                            <div class="version-details">
                                <div class="version-detail">
                                    <strong>Size:</strong>
                                    <span>${formatFileSize(version.Size || 0)}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Modified:</strong>
                                    <span>${new Date(version.LastModified).toLocaleString()}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Storage:</strong>
                                    <span>${version.StorageClass || 'STANDARD'}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Version ID:</strong>
                                    <span>${version.VersionId || 'N/A'}</span>
                                </div>
                            </div>
                            <div class="version-actions">
                                <button class="btn btn-small" onclick="showMetadata('${key}', '${version.VersionId || ''}')">ℹ️ View Metadata</button>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 20px; color: #6c757d;">
                            <p><strong>Note:</strong> Versioning may not be enabled on this bucket. Use "ℹ️ Info" for detailed metadata.</p>
                        </div>
                    `;
                } else {
                    let versionsHtml = `
                        <div style="margin-bottom: 15px; text-align: center;">
                            <h4>📊 Found ${versions.length} versions</h4>
                        </div>
                    `;
                    
                    versions.forEach((version, index) => {
                        const isLatest = version.IsLatest || index === 0;
                        const isDeleted = version.Type === 'deleteMarker';
                        
                        const versionClass = isDeleted ? 'deleted' : (isLatest ? 'current' : '');
                        const versionTitle = isDeleted ? `🗑️ Deleted Version ${index + 1}` : 
                                           `${isLatest ? '✅' : '📌'} Version ${index + 1}${isLatest ? ' (Current)' : ''}`;
                        const badgeClass = isDeleted ? 'deleted' : (isLatest ? 'current' : '');
                        const badgeText = isDeleted ? 'Deleted' : (isLatest ? 'Current' : 'Version');
                        
                        versionsHtml += `
                            <div class="version-item ${versionClass}">
                                <div class="version-header">
                                    <span class="version-title ${versionClass}">${versionTitle}</span>
                                    <span class="version-badge-modal ${badgeClass}">${badgeText}</span>
                                </div>
                                <div class="version-details">
                        `;
                        
                        if (isDeleted) {
                            versionsHtml += `
                                <div class="version-detail">
                                    <strong>Deleted:</strong>
                                    <span>${new Date(version.LastModified).toLocaleString()}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Version ID:</strong>
                                    <span>${version.VersionId || 'N/A'}</span>
                                </div>
                            `;
                        } else {
                            versionsHtml += `
                                <div class="version-detail">
                                    <strong>Size:</strong>
                                    <span>${formatFileSize(version.Size || 0)}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Modified:</strong>
                                    <span>${new Date(version.LastModified).toLocaleString()}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Storage:</strong>
                                    <span>${version.StorageClass || 'STANDARD'}</span>
                                </div>
                                <div class="version-detail">
                                    <strong>Version ID:</strong>
                                    <span>${version.VersionId || 'N/A'}</span>
                                </div>
                            `;
                        }
                        
                        versionsHtml += `
                                </div>
                        `;
                        
                        if (!isDeleted) {
                            versionsHtml += `
                                <div class="version-actions">
                                    <button class="btn btn-small" onclick="showMetadata('${key}', '${version.VersionId || ''}')">ℹ️ View Metadata</button>
                                </div>
                            `;
                        }
                        
                        versionsHtml += `</div>`;
                    });
                    
                    versionsHtml += `
                        <div style="text-align: center; margin-top: 20px; color: #6c757d;">
                            <p><strong>Note:</strong> This is a read-only browser. Use "ℹ️ View Metadata" for specific version details.</p>
                        </div>
                    `;
                    
                    modalBody.innerHTML = versionsHtml;
                }
                
                // Show the modal
                document.getElementById('versionModal').style.display = 'block';
                
            } catch (error) {
                console.error('Error fetching file details:', error);
                // Fallback to alert for errors
                alert(`📄 File: ${key}\n\n⚠️ Could not load version details: ${error.message}\n\n💡 This is a read-only browser.\nUse the "ℹ️ Info" button to view metadata for the current version.`);
            }
        }

        // Close version modal
        function closeVersionModal() {
            document.getElementById('versionModal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('versionModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Show read-only message when user clicks on file names
        function showReadOnlyMessage() {
            alert('📥 Download not permitted. This viewer is read-only.\n\nUse the "ℹ️ Info" button to view file metadata.');
        }

        // Download file
        // No download functionality - read-only access

        // Refresh buckets
        function refreshBuckets() {
            document.getElementById('bucketSelect').selectedIndex = 0;
            currentBucket = '';
            currentPrefix = '';
            showEmptyState();
            loadBuckets();
        }

        // Reload credentials
        async function reloadCredentials() {
            try {
                const response = await fetch(apiUrl('/api/reload-credentials'), { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    alert('Credentials reloaded successfully!');
                    refreshBuckets();
                } else {
                    alert(`Failed to reload credentials: ${data.message}`);
                }
            } catch (error) {
                console.error('Error reloading credentials:', error);
                alert(`Error reloading credentials: ${error.message}`);
            }
        }

        // Selection management functions
        function toggleSelection(path, type, isChecked) {
            console.log(`Toggle selection: ${path}, type: ${type}, checked: ${isChecked}`);
            
            if (isChecked) {
                // Adding an item to selection
                if (type === 'folder') {
                    // Standardize folder pattern - always use path/* format (without trailing slash before /*)
                    const normalizedPath = path.endsWith('/') ? path.slice(0, -1) : path;
                    const folderPattern = normalizedPath + '/*';
                    
                    // Remove any existing patterns for this folder first
                    const existingPatterns = Array.from(selectedItems).filter(item => {
                        const itemPath = item.replace('/*', '').replace(/\*$/, '');
                        return itemPath === normalizedPath;
                    });
                    existingPatterns.forEach(pattern => selectedItems.delete(pattern));
                    
                    selectedItems.add(folderPattern);
                    console.log(`Added folder pattern: ${folderPattern}`);
                    
                    // Remove any individual files under this folder that were previously selected
                    const filesToRemove = Array.from(selectedItems).filter(item => 
                        item.startsWith(normalizedPath + '/') && !item.includes('*')
                    );
                    filesToRemove.forEach(file => selectedItems.delete(file));
                } else {
                    // For files, check if parent folder is already selected
                    const parentSelected = Array.from(selectedItems).some(item => {
                        if (item.includes('*')) {
                            const folderPath = item.replace('/*', '');
                            return path.startsWith(folderPath + '/');
                        }
                        return false;
                    });
                    
                    if (!parentSelected) {
                        selectedItems.add(path);
                        console.log(`Added file: ${path}`);
                    }
                }
            } else {
                // Removing an item from selection
                if (type === 'folder') {
                    const normalizedPath = path.endsWith('/') ? path.slice(0, -1) : path;
                    
                    // Find parent folder patterns that might contain this folder
                    const parentPatterns = Array.from(selectedItems).filter(item => {
                        if (!item.includes('*')) return false;
                        const parentPath = item.replace('/*', '').replace(/\*$/, '');
                        return normalizedPath.startsWith(parentPath + '/') && parentPath !== normalizedPath;
                    });
                    
                    if (parentPatterns.length > 0) {
                        // This folder is under a parent selection - need to break up the parent
                        parentPatterns.forEach(parentPattern => {
                            selectedItems.delete(parentPattern);
                            console.log(`Removed parent pattern: ${parentPattern}`);
                            
                            const parentPath = parentPattern.replace('/*', '');
                            
                            // Re-add all items under the parent except the one being deselected
                            currentFolders.forEach(folder => {
                                const folderNormalized = folder.Prefix.endsWith('/') ? 
                                    folder.Prefix.slice(0, -1) : folder.Prefix;
                                if (folderNormalized.startsWith(parentPath + '/') && folderNormalized !== normalizedPath) {
                                    selectedItems.add(folderNormalized + '/*');
                                }
                            });
                            
                            currentFiles.forEach(file => {
                                if (file.Key.startsWith(parentPath + '/') && !file.Key.startsWith(normalizedPath + '/')) {
                                    selectedItems.add(file.Key);
                                }
                            });
                        });
                    } else {
                        // Direct folder selection - just remove it
                        const patterns = [
                            normalizedPath + '/*',
                            path.endsWith('/') ? path + '*' : path + '/*',
                            path
                        ];
                        
                        patterns.forEach(pattern => {
                            if (selectedItems.has(pattern)) {
                                selectedItems.delete(pattern);
                                console.log(`Removed folder pattern: ${pattern}`);
                            }
                        });
                    }
                } else {
                    // For files, check if it's part of a selected folder pattern
                    const parentFolderPattern = Array.from(selectedItems).find(item => {
                        if (item.includes('*')) {
                            const folderPath = item.replace('/*', '');
                            return path.startsWith(folderPath + '/');
                        }
                        return false;
                    });
                    
                    if (parentFolderPattern) {
                        // Remove the folder pattern and add individual files except the deselected one
                        selectedItems.delete(parentFolderPattern);
                        console.log(`Removed parent folder pattern: ${parentFolderPattern}`);
                        
                        const folderPath = parentFolderPattern.replace('/*', '');
                        
                        // Add back all other items under this folder except the unchecked one
                        currentFiles.forEach(file => {
                            if (file.Key.startsWith(folderPath + '/') && file.Key !== path) {
                                selectedItems.add(file.Key);
                            }
                        });
                        
                        // Add other folders in current view that were under the parent
                        currentFolders.forEach(folder => {
                            const normalizedFolderPath = folder.Prefix.endsWith('/') ? 
                                folder.Prefix.slice(0, -1) : folder.Prefix;
                            if (normalizedFolderPath.startsWith(folderPath + '/')) {
                                const subFolderPattern = normalizedFolderPath + '/*';
                                selectedItems.add(subFolderPattern);
                            }
                        });
                    } else {
                        // File is individually selected, just remove it
                        selectedItems.delete(path);
                        console.log(`Removed file: ${path}`);
                    }
                }
            }
            
            console.log('Final selections after toggle:', Array.from(selectedItems));
            updateSelectionUI();
        }

        function isItemSelected(path) {
            // Check if the item itself is selected
            if (selectedItems.has(path)) return true;
            
            // For folders, check both possible patterns (with and without trailing slash)
            const normalizedPath = path.endsWith('/') ? path.slice(0, -1) : path;
            const folderPattern1 = normalizedPath + '/*';
            const folderPattern2 = path.endsWith('/') ? path + '*' : path + '/*';
            
            if (selectedItems.has(folderPattern1) || selectedItems.has(folderPattern2)) return true;
            
            // Check if item is under a selected folder pattern
            // Only consider it selected if there's a parent pattern that covers it
            return Array.from(selectedItems).some(item => {
                if (item.includes('*')) {
                    const folderPath = item.replace('/*', '').replace(/\*$/, '');
                    // Make sure the folder path is actually a parent (not the same path)
                    return folderPath !== normalizedPath && 
                           (path.startsWith(folderPath + '/') || 
                            (path.endsWith('/') && path.slice(0, -1).startsWith(folderPath + '/')));
                }
                return false;
            });
        }

        function updateSelectionUI() {
            // Update checkboxes to reflect current selection state
            document.querySelectorAll('.selection-checkbox').forEach(checkbox => {
                const path = checkbox.dataset.path;
                checkbox.checked = isItemSelected(path);
            });
            
            // Update selection count display
            updateSelectionCount();
        }

        function updateSelectionCount() {
            const count = selectedItems.size;
            if (count > 0) {
                document.getElementById('selectionControls').style.display = 'block';
            }
        }

        function selectAll() {
            selectedItems.clear();
            
            // Select all folders
            currentFolders.forEach(folder => {
                const folderPattern = folder.Prefix.endsWith('/') ? 
                    folder.Prefix + '*' : folder.Prefix + '/*';
                selectedItems.add(folderPattern);
            });
            
            // Select all files that aren't under selected folders
            currentFiles.forEach(file => {
                const underSelectedFolder = currentFolders.some(folder => 
                    file.Key.startsWith(folder.Prefix)
                );
                
                if (!underSelectedFolder) {
                    selectedItems.add(file.Key);
                }
            });
            
            updateSelectionUI();
        }

        function clearSelection() {
            selectedItems.clear();
            updateSelectionUI();
            document.getElementById('selectionSummary').style.display = 'none';
        }

        function showSelectionDetails() {
            const summaryDiv = document.getElementById('selectionSummary');
            const listDiv = document.getElementById('selectionList');
            
            if (selectedItems.size === 0) {
                listDiv.innerHTML = '<div class="selection-item">No items selected</div>';
            } else {
                const items = Array.from(selectedItems).sort();
                listDiv.innerHTML = items.map(item => 
                    `<div class="selection-item">${item}</div>`
                ).join('');
            }
            
            summaryDiv.style.display = summaryDiv.style.display === 'none' ? 'block' : 'none';
        }

        // Copy selection list to clipboard
        function copySelectionToClipboard() {
            if (selectedItems.size === 0) {
                alert('No items selected to copy');
                return;
            }

            const items = Array.from(selectedItems).sort();
            const text = items.join('\n');
            
            // Use the Clipboard API if available
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    alert(`Copied ${items.length} items to clipboard`);
                }).catch(err => {
                    console.error('Failed to copy to clipboard:', err);
                    fallbackCopyToClipboard(text);
                });
            } else {
                fallbackCopyToClipboard(text);
            }
        }

        // Fallback copy method for older browsers or non-secure contexts
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.top = '0';
            textArea.style.left = '0';
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            textArea.style.padding = '0';
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            textArea.style.background = 'transparent';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                const items = Array.from(selectedItems);
                if (successful) {
                    alert(`Copied ${items.length} items to clipboard`);
                } else {
                    alert('Failed to copy to clipboard');
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                alert('Copy to clipboard not supported in this browser');
            }
            
            document.body.removeChild(textArea);
        }

        // Utility functions
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            hideError();
            hideEmptyState();
        }

        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            hideEmptyState();
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }

        function showEmptyState() {
            document.getElementById('emptyState').style.display = 'block';
            document.getElementById('folderList').style.display = 'none';
            document.getElementById('fileList').style.display = 'none';
            document.getElementById('statusBar').style.display = 'none';
        }

        function hideEmptyState() {
            document.getElementById('emptyState').style.display = 'none';
        }

        function showEmptyFolder() {
            document.getElementById('emptyState').innerHTML = `
                <h3>📂 Empty Folder</h3>
                <p>This folder contains no files or subfolders</p>
            `;
            showEmptyState();
        }

        function updateStatusBar(folderCount, fileCount) {
            const statusBar = document.getElementById('statusBar');
            const statusText = document.getElementById('statusText');
            
            let text = '';
            if (folderCount > 0) {
                text += `${folderCount} folder${folderCount !== 1 ? 's' : ''}`;
            }
            if (fileCount > 0) {
                if (text) text += ', ';
                text += `${fileCount} file${fileCount !== 1 ? 's' : ''}`;
            }
            
            statusText.textContent = text;
            statusBar.style.display = 'block';
        }
    </script>
</body>
</html>
